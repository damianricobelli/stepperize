---
title: Hook
description: Access and control your stepper with the useStepper hook
---

The `useStepper` hook returns the stepper instance with a structured API: **state**, **navigation**, **lookup**, **flow**, **metadata**, and **lifecycle**. Inside `<Scoped>` or `Stepper.Root`, `useStepper()` (with no arguments) reads from context. In a component with no provider, `useStepper()` creates its own stepper state for that component. You can still pass config when outside a provider to set `initialStep` and `initialMetadata`.

The hook accepts an optional single argument: a config object with:

- **`initialStep`** — The ID of the initial step (must be one of your step IDs).
- **`initialMetadata`** — Partial record of step ID → metadata; used to seed `metadata.get(id)` and `state.current.metadata` per step.

## Usage

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First step" },
  { id: "second", title: "Second step" }
);

const MyStepperComponent = () => {
  const stepper = useStepper();
  return (
    <div>
      <h1>{stepper.state.current.data.title}</h1>
      <button onClick={() => stepper.navigation.next()} disabled={stepper.state.isLast}>Next</button>
      <button onClick={() => stepper.navigation.prev()} disabled={stepper.state.isFirst}>Previous</button>
    </div>
  );
};
```

## Rendering methods

The stepper exposes **`flow`** with helpers to render content by step: **`flow.is`**, **`flow.when`**, **`flow.switch`**, and **`flow.match`**.

### when

The `flow.when` method allows rendering content conditionally based on the current step. It takes a step ID (string or array of ID plus conditions), a `whenFn` (the function to run if the step matches), and an optional `elseFn` (run when it does not match).

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First step" },
  { id: "second", title: "Second step" }
);

const MyStepperComponent = () => {
  const stepper = useStepper();
  return (
    <div>
      {stepper.flow.when("first", (step) => (
        <p>First step: {step.title}</p>
      ))}
      {stepper.flow.when("second", (step) => (
        <p>Second step: {step.title}</p>
      ))}
    </div>
  );
};
```

You can pass an optional `elseFn` to render when the current step does not match:

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "info", title: "Info" },
  { id: "review", title: "Review" },
  { id: "done", title: "Done" }
);

function Content() {
  const stepper = useStepper();
  return (
    <div>
      {stepper.flow.when(
        "review",
        (step) => <p>You're on review: {step.title}</p>,
        (step) => <p>Other step: {step.title}</p>
      )}
    </div>
  );
}
```

You can also use an array as the first argument: the first element is the step ID, the rest are boolean conditions. The step matches only when the ID matches and all conditions are `true`. This allows multi-condition logic (e.g. step + feature flag or validation state).

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First step" },
  { id: "second", title: "Second step" }
);

const MyStepperComponent = () => {
  const stepper = useStepper();
  const canEdit = true;
  const isReady = true;
  return (
    <div>
      {stepper.flow.when(["first", canEdit, isReady], (step) => (
        <p>First step (editable): {step.title}</p>
      ))}
      {stepper.flow.when("second", (step) => (
        <p>Second step: {step.title}</p>
      ))}
    </div>
  );
};
```

### switch

The `flow.switch` method lets you render content based on the current step ID in a switch-case style. It is a cleaner and more scalable way to handle many steps without multiple `when` conditions.

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First step" },
  { id: "second", title: "Second step" }
);

const MyStepperComponent = () => {
  const stepper = useStepper();
  return (
    <div>
      {stepper.flow.switch({
        first: (step) => <p>First: {step.title}</p>,
        second: (step) => <p>Second: {step.title}</p>,
      })}
    </div>
  );
};
```

### match

The `flow.match` method lets you render content based on an **external** step ID (e.g. from the server, URL, or other state). Unlike `flow.switch`, which uses the stepper’s current step, `flow.match` takes that ID as the first argument. Useful for frameworks like Remix with server-side state or when driving the UI from a URL param.

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First step" },
  { id: "second", title: "Second step" }
);

const MyStepperComponent = () => {
  const stepper = useStepper();
  const state = "first"; // e.g. from server or URL
  return (
    <div>
      {stepper.flow.match(state, {
        first: (step) => <p>First: {step.title}</p>,
        second: (step) => <p>Second: {step.title}</p>,
      })}
    </div>
  );
};
```

### is

For simple conditionals, use `flow.is(id)`. It returns `true` when the current step’s ID equals `id`.

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "form", title: "Form" },
  { id: "confirmation", title: "Confirmation" }
);

function Content() {
  const stepper = useStepper();
  return (
    <div>
      {stepper.flow.is("confirmation") && <p>Order summary here.</p>}
      {stepper.flow.is("form") && <p>Fill the form.</p>}
    </div>
  );
}
```

## State and navigation

| Property / Method | Description |
| ----------------- | ----------- |
| `state.all` | Array of all step objects |
| `state.current` | `{ data, index, status, metadata }` — current step; use `state.current.metadata.get/set/reset` for current step only |
| `state.isFirst` / `state.isLast` | `true` when on first or last step |
| `state.isTransitioning` | `true` while a transition (with lifecycle callbacks) is in progress |
| `navigation.next()` | Go to next step |
| `navigation.prev()` | Go to previous step |
| `navigation.goTo(id)` | Go to step by ID |
| `navigation.reset()` | Reset to initial step |

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "info", title: "Info" },
  { id: "review", title: "Review" },
  { id: "done", title: "Done" }
);

function NavExample() {
  const stepper = useStepper();
  return (
    <div>
      <p>Step {stepper.state.current.index + 1}: {stepper.state.current.data.title}</p>
      <button type="button" onClick={() => stepper.navigation.prev()} disabled={stepper.state.isFirst}>Back</button>
      <button type="button" onClick={() => stepper.navigation.next()} disabled={stepper.state.isLast}>Next</button>
      <button type="button" onClick={() => stepper.navigation.goTo("review")}>Jump to Review</button>
      <button type="button" onClick={() => stepper.navigation.reset()}>Reset</button>
    </div>
  );
}
```

## Lookup

Step lookup helpers (same shape as `generateStepperUtils` from `@stepperize/core`):

| Method | Description |
| ------ | ----------- |
| `lookup.getAll()` | All steps |
| `lookup.get(id)` | Step object by ID |
| `lookup.getIndex(id)` | Index of step by ID |
| `lookup.getByIndex(index)` | Step at index |
| `lookup.getFirst()` / `lookup.getLast()` | First / last step |
| `lookup.getNext(id)` / `lookup.getPrev(id)` | Next / previous step after `id` |
| `lookup.getNeighbors(id)` | `{ prev, next }` for step `id` |

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "info", title: "Info" },
  { id: "review", title: "Review" },
  { id: "done", title: "Done" }
);

function LookupExample() {
  const stepper = useStepper();
  const step = stepper.lookup.get("review");
  const neighbors = stepper.lookup.getNeighbors(stepper.state.current.data.id);
  return (
    <p>Review: {step?.title}; neighbors: {neighbors.prev?.id ?? "none"} → {neighbors.next?.id ?? "none"}</p>
  );
}
```

## Transition hooks (before / after)

For actions before or after a transition (e.g. validation, analytics), use **`stepper.lifecycle.onBeforeTransition(cb)`** and **`stepper.lifecycle.onAfterTransition(cb)`**. Multiple callbacks are supported (e.g. one at the Stepper level, one per step); each call returns an **unsubscribe** function. They run on every `next()`, `prev()`, and `goTo()`. Return `false` (or a promise that resolves to `false`) from `onBeforeTransition` to cancel the transition.

The callback receives a **TransitionContext** with: `from`, `to`, `metadata`, `statuses`, `direction` (`"next"` | `"prev"` | `"goTo"`), `fromIndex`, `toIndex`. Use `direction` to branch (e.g. run logic only before "next" or "prev").

To avoid stale metadata in the hook when you set metadata and then call `next()`, `prev()`, or `goTo()` in the same handler, pass a **payload** into navigation: **`next({ metadata: { "step-id": { ... } } })`**, **`prev({ metadata: ... })`**, or **`goTo(id, { metadata: ... })`**. That metadata is merged into `ctx.metadata` for the transition and persisted.

### onBeforeTransition

Runs before the step index updates. Return `false` to cancel.

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First" },
  { id: "second", title: "Second" }
);

function MyStepper() {
  const stepper = useStepper();
  React.useEffect(() => {
    const unsub = stepper.lifecycle.onBeforeTransition(async (ctx) => {
      if (ctx.direction === "prev" && !window.confirm("Go back?")) return false;
    });
    return () => unsub();
  }, [stepper]);
  return (
    <button type="button" onClick={() => stepper.navigation.next()} disabled={stepper.state.isLast}>
      Next
    </button>
  );
}
```

### Multiple callbacks (Stepper + step) and unsubscribe

You can register one handler at the Stepper level and another inside a step component; **all run in registration order**. If any `onBeforeTransition` callback returns `false`, the transition is cancelled. Each call returns an **unsubscribe** function — use it in your `useEffect` cleanup so the handler is removed when the component unmounts (e.g. when navigating away from that step).

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "step-1", title: "Step 1" },
  { id: "step-2", title: "Step 2" }
);

function StepperWrapper() {
  const stepper = useStepper();
  React.useEffect(() => {
    const unsub = stepper.lifecycle.onBeforeTransition(async (ctx) => {
      if (ctx.direction === "prev" && !window.confirm("Go back?")) return false;
    });
    return () => unsub();
  }, [stepper]);
  return (
    <>
      {stepper.flow.switch({
        "step-1": () => <Step1 />,
        "step-2": () => <Step2 />,
      })}
    </>
  );
}

function Step1() {
  const stepper = useStepper();
  React.useEffect(() => {
    const unsub = stepper.lifecycle.onBeforeTransition(async (ctx) => {
      if (ctx.from.id === "step-1") {
        // Step-specific validation; both this and the global handler run
        const ok = await validateStep1();
        if (!ok) return false;
      }
    });
    return () => unsub();
  }, [stepper]);
  return (
    <button type="button" onClick={() => stepper.navigation.next()}>
      Next
    </button>
  );
}

function Step2() {
  return <p>Step 2</p>;
}

async function validateStep1(): Promise<boolean> {
  return true;
}
```

### Passing metadata in the transition (avoid stale ctx)

If you set metadata and then call `next()` in the same handler, `onBeforeTransition` still sees the previous metadata (setState is async). Pass a payload so the hook receives fresh data. The same payload works for **`next(payload)`**, **`prev(payload)`**, and **`goTo(id, payload)`**:

```tsx
const handleNext = async () => {
  const url = await generateUrl();
  stepper.navigation.next({ metadata: { "step-1": { ...step1Meta, data: { url } } } });
};

stepper.navigation.prev({ metadata: { "step-1": { reason: "back" } } });
stepper.navigation.goTo("summary", { metadata: { "payment": { method: "card" } } });
```

### onAfterTransition

Runs after the step index has updated.

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First" },
  { id: "second", title: "Second" }
);

function MyStepper() {
  const stepper = useStepper();
  React.useEffect(() => {
    const unsub = stepper.lifecycle.onAfterTransition((ctx) => {
      console.log(`${ctx.from.id} → ${ctx.to.id}`);
    });
    return () => unsub();
  }, [stepper]);
  return (
    <button type="button" onClick={() => stepper.navigation.next()} disabled={stepper.state.isLast}>
      Next
    </button>
  );
}
```

## Metadata

Metadata lets you attach custom data per step (e.g. form drafts, values from the server). You can set initial metadata in the hook config and read/write it at runtime.

### Initial metadata

Pass **`initialMetadata`** in `useStepper({ ... })` to seed metadata per step:

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First step" },
  { id: "second", title: "Second step" }
);

const MyStepperComponent = () => {
  const stepper = useStepper({
    initialMetadata: {
      first: { value: "1" },
    },
  });
  const firstMeta = stepper.metadata.get("first");
  return <p>First step: {firstMeta?.value}</p>;
};
```

### set / get / reset

- **`metadata.set(id, values)`** — Set metadata for a step.
- **`metadata.get(id)`** — Get metadata for a step.
- **`metadata.reset(keepInitialMetadata?)`** — Reset all metadata; pass `true` to keep initial values from config.

Current step only: **`state.current.metadata.get()`**, **`state.current.metadata.set(values)`**, **`state.current.metadata.reset()`**.

```tsx twoslash
import * as React from "react";
import { defineStepper } from "@stepperize/react";

const { useStepper } = defineStepper(
  { id: "first", title: "First step" },
  { id: "second", title: "Second step" },
  { id: "last", title: "Last step" }
);

const MyStepperComponent = () => {
  const stepper = useStepper();
  const handleSave = () => {
    stepper.metadata.set("first", { value: "saved" });
  };
  const meta = stepper.metadata.get("first");
  return (
    <div>
      <button type="button" onClick={handleSave}>Save</button>
      <p>First step: {meta?.value}</p>
      <button type="button" onClick={() => stepper.metadata.reset(true)}>Reset metadata</button>
    </div>
  );
};
```

## API reference

| Name | Type | Description |
| ---- | ---- | ----------- |
| `state` | `StepperState<Steps>` | `all`, `current` (data, index, status, metadata), `isFirst`, `isLast`, `isTransitioning` |
| `navigation` | `StepperNavigation<Steps>` | `next(payload?)`, `prev(payload?)`, `goTo(id, payload?)`, `reset()` — payload can include `metadata` to merge into transition context |
| `lookup` | `StepperLookup<Steps>` | `getAll()`, `get(id)`, `getIndex(id)`, `getByIndex(index)`, `getFirst()` / `getLast()`, `getNext(id)` / `getPrev(id)`, `getNeighbors(id)` |
| `flow` | `StepperFlow<Steps>` | `is(id)`, `when(id, whenFn, elseFn?)`, `switch(when)`, `match(state, matches)` |
| `metadata` | `StepperMetadata<Steps>` | `values`, `set(id, values)`, `get(id)`, `reset(keepInitialMetadata?)` |
| `lifecycle` | `{ onBeforeTransition, onAfterTransition }` | Register callbacks (multiple supported); each returns unsubscribe; return `false` from `onBeforeTransition` to cancel |
